// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2020-2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Phase 3 terminal composite.
// Adapted by mewmix and Codex (2025).

uniform float4x4 ViewProj;
uniform texture2d image;

uniform float elapsed_time;
uniform float2 uv_offset;
uniform float2 uv_scale;
uniform float2 uv_pixel_interval;
uniform float2 uv_size;

sampler_state textureSampler {
  Filter = Linear;
  AddressU = Wrap;
  AddressV = Wrap;
};

struct VertData {
  float4 pos : POSITION;
  float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in) {
  VertData v_out;
  v_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
  v_out.uv = v_in.uv * uv_scale + uv_offset;
  return v_out;
}

float smoothstep(float a, float b, float x) {
  float t = saturate((x - a) / (b - a));
  return t * t * (3.0 - 2.0 * t);
}

float hash(float2 p) {
  p = frac(p * float2(123.34, 345.45));
  p += dot(p, p + 34.345);
  return frac(p.x * p.y);
}

float2 barrel(float2 uv, float k) {
  float2 p = uv * 2.0 - 1.0;
  float aspect = uv_size.x / uv_size.y;
  p.x *= aspect;
  float r2 = dot(p, p);
  p *= 1.0 + k * r2;
  p.x /= aspect;
  return p * 0.5 + 0.5;
}

float luma(float3 c) { return dot(c, float3(0.299, 0.587, 0.114)); }

float blurLuma(float2 uv, float2 px) {
  float s = 0.0;
  float2 off = px * 1.6;
  s += luma(image.Sample(textureSampler, uv + off * float2( 1.0, 0.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2(-1.0, 0.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2( 0.0, 1.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2( 0.0,-1.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2( 1.0, 1.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2(-1.0, 1.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2( 1.0,-1.0)).rgb);
  s += luma(image.Sample(textureSampler, uv + off * float2(-1.0,-1.0)).rgb);
  return s / 8.0;
}

float4 mainImage(VertData v_in) : TARGET {
  float2 screenUV = barrel(v_in.uv, 0.06);

  if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
    return float4(0.0, 0.0, 0.0, 1.0);
  }

  float burstPeriod = 120.0;
  float flickerDur = 0.06;
  float rollDur = 0.14;
  float cycle = frac(elapsed_time / burstPeriod);
  float vOffset = 0.0;

  float2 sourceUV = screenUV;
  if (cycle < flickerDur) {
    vOffset = 0.0;
  } else if (cycle < (flickerDur + rollDur)) {
    float rollSpeed = 2.5;
    vOffset = frac(elapsed_time * rollSpeed);
  }
  sourceUV.y = frac(sourceUV.y + vOffset);

  float3 src = image.Sample(textureSampler, sourceUV).rgb;
  float y = luma(src);
  src = lerp(float3(y, y, y), src, 0.08);
  float yDetail = luma(src);

  float t = yDetail;
  t = pow(t, 0.95);
  t = smoothstep(0.03, 0.92, t);
  t = t / (t + 0.35);

  float sl1 = 0.94 + 0.06 * sin((screenUV.y * uv_size.y) * 3.14159);
  float sl2 = 0.97 + 0.03 * sin((screenUV.y * uv_size.y) * 6.28318);
  float scan = sl1 * sl2;

  float mask = 0.985 + 0.015 * sin((screenUV.x * uv_size.x) * 2.0);

  float flickerBase = 0.992 + 0.008 * sin(elapsed_time * 55.0);
  float flickerBoost = 1.0;
  if (cycle < flickerDur) {
    flickerBoost = 0.9 + 0.1 * sin(elapsed_time * 180.0 * 6.28);
  } else if (cycle < (flickerDur + rollDur)) {
    flickerBoost = 0.95 + 0.05 * sin(elapsed_time * 120.0 * 6.28);
  }
  float flicker = flickerBase * flickerBoost;

  float bandPos = frac(elapsed_time * 0.10);
  float band = 1.0 + 0.06 * exp(-pow((screenUV.y - bandPos) * 10.0, 2.0));

  float n = hash(screenUV * uv_size + float2(elapsed_time * 60.0, elapsed_time * 11.0));
  float grain = (n - 0.5) * 0.05;

  float2 px = uv_pixel_interval;
  float b = blurLuma(sourceUV, px);
  float bloom = max(0.0, b - 0.5) * 0.25;
  float halo = max(0.0, b - 0.35) * 0.06;

  float2 p = screenUV * 2.0 - 1.0;
  float aspect = uv_size.x / uv_size.y;
  p.x *= aspect;
  float r2 = dot(p, p);
  float vig = 1.0 - 0.25 * r2;
  vig *= smoothstep(1.4, 0.5, r2);
  vig = clamp(vig, 0.0, 1.0);

  float intensity = max(t, 0.04);
  intensity += bloom;
  intensity = (intensity + grain) * scan * mask * flicker * band * vig;
  intensity = saturate(intensity);

  float3 phosphorShadow = float3(0.12, 0.22, 0.14);
  float3 phosphorBase   = float3(0.30, 0.55, 0.36);
  float3 phosphorGlow   = float3(0.26, 0.50, 0.34);
  float3 phosphorHi     = float3(0.60, 0.92, 0.70);

  float i = intensity;
  float3 col = lerp(phosphorShadow, phosphorBase, smoothstep(0.05, 0.55, i));
  col = lerp(col, phosphorHi, smoothstep(0.60, 1.00, i));
  col += phosphorGlow * bloom * 1.2;
  col += phosphorGlow * halo * 0.6;

  return float4(saturate(col), 1.0);
}

technique Draw {
  pass {
    vertex_shader = VSDefault(v_in);
    pixel_shader = mainImage(v_in);
  }
}
