<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Mr. House CRT Cam</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
    }

    #gl {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #hint {
      position: fixed;
      top: 12px;
      left: 12px;
      color: #9f9;
      font: 14px/1.3 system-ui;
      background: rgba(0, 0, 0, 0.55);
      padding: 10px 12px;
      border: 1px solid rgba(120, 255, 120, 0.25);
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div id="hint">
    Mr. House CRT cam (prototype).<br />
    Use OBS Window Capture → Start Virtual Camera.
  </div>
  <canvas id="gl"></canvas>
  <video id="vid" playsinline autoplay muted style="display:none;"></video>

  <script>
    (async () => {
      const video = document.getElementById('vid');
      const canvas = document.getElementById('gl');

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();

      const gl = canvas.getContext('webgl', { premultipliedAlpha: false });
      if (!gl) throw new Error("WebGL not available");

      function resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.floor(canvas.clientWidth * dpr);
        canvas.height = Math.floor(canvas.clientHeight * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      new ResizeObserver(resize).observe(canvas);
      resize();

      const vs = `
    attribute vec2 a_pos;
    varying vec2 v_uv;
    void main() {
      v_uv = (a_pos + 1.0) * 0.5;
      gl_Position = vec4(a_pos, 0.0, 1.0);
    }
  `;

      const fs = `
precision mediump float;

uniform sampler2D u_tex;
uniform vec2 u_res;
uniform float u_time;
uniform float u_flip;
varying vec2 v_uv;

float hash(vec2 p) {
  p = fract(p * vec2(123.34, 345.45));
  p += dot(p, p + 34.345);
  return fract(p.x * p.y);
}

vec2 barrel(vec2 uv, float k) {
  vec2 p = uv * 2.0 - 1.0;
  float r2 = dot(p, p);
  p *= 1.0 + k * r2;
  return p * 0.5 + 0.5;
}

float luma(vec3 c) { return dot(c, vec3(0.299, 0.587, 0.114)); }

// Simple multi-tap blur for halation (cheap bloom)
float blurLuma(vec2 uv, vec2 px) {
  float s = 0.0;
  s += luma(texture2D(u_tex, uv + px*vec2( 1.0, 0.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2(-1.0, 0.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2( 0.0, 1.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2( 0.0,-1.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2( 1.0, 1.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2(-1.0, 1.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2( 1.0,-1.0)).rgb);
  s += luma(texture2D(u_tex, uv + px*vec2(-1.0,-1.0)).rgb);
  return s / 8.0;
}

void main() {
  // Curvature (slightly less than your current 0.10 tends to look more "TV prop")
  vec2 uv = barrel(v_uv, 0.075);

  // Outside screen => black
  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
    gl_FragColor = vec4(0.0);
    return;
  }

  vec2 srcUV = uv;
  if (u_flip > 0.5) srcUV = 1.0 - srcUV;

  vec3 src = texture2D(u_tex, srcUV).rgb;

  // Slight pre-desat so the phosphor mapping doesn't inherit camera colors too strongly
  float y = luma(src);
  // keep a tiny bit of source structure (helps faces look less flat)
  float yDetail = luma(mix(vec3(y), src, 0.12));

  // Tube-ish tone curve: lift blacks a touch, compress highlights
  float t = yDetail;
  t = pow(t, 0.95);                 // mild gamma
  t = smoothstep(0.03, 0.92, t);    // softer contrast than your crush
  // gentle shoulder (keeps highlights "milky")
  t = t / (t + 0.35);

  // Scanlines (softer + less “stripy” than your current)
  float sl1 = 0.94 + 0.06 * sin((uv.y * u_res.y) * 3.14159);
  float sl2 = 0.97 + 0.03 * sin((uv.y * u_res.y) * 6.28318);
  float scan = sl1 * sl2;

  // Very subtle vertical mask / banding
  float mask = 0.985 + 0.015 * sin((uv.x * u_res.x) * 2.0);

  // Subtle flicker
  float flicker = 0.992 + 0.008 * sin(u_time * 55.0);

  // Rolling refresh band (keep it subtle; TV show look is present but not arcade-strong)
  float bandPos = fract(u_time * 0.10);
  float band = 1.0 + 0.06 * exp(-pow((uv.y - bandPos) * 10.0, 2.0));

  // Noise: fine grain, not “snow”
  float n = hash(uv * u_res + vec2(u_time * 60.0, u_time * 11.0));
  float grain = (n - 0.5) * 0.04;

  // Halation / bloom: stronger and wider than your current
  vec2 px = 1.0 / u_res;
  float b = blurLuma(srcUV, px * 1.6);
  float bloom = max(0.0, b - 0.55) * 0.22;   // threshold + gain
  float halo  = max(0.0, b - 0.35) * 0.05;   // low-threshold “glass haze”

  // Vignette + edge darkening (film/photo of CRT)
  vec2 p = uv * 2.0 - 1.0;
  float r2 = dot(p, p);
  float vig = 1.0 - 0.30 * r2;
  vig *= smoothstep(1.05, 0.55, r2); // stronger corners
  vig = clamp(vig, 0.0, 1.0);

  // Final intensity
  float intensity = t;
  intensity += bloom;
  intensity = (intensity + grain) * scan * mask * flicker * band * vig;
  intensity = clamp(intensity, 0.0, 1.0);

  // Fallout-TV phosphor palette: muted green/gray with warmer highlights
  // (This is the main fix vs your neon vec3(0.06,1.00,0.18) mapping.)
  vec3 phosphorBase = vec3(0.54, 0.86, 0.66); // milky green w/ gray
  vec3 phosphorWarm = vec3(0.80, 0.96, 0.62); // warmer/yellow-ish in brights

  // Tint blend: more warm only near top end
  float warmMix = smoothstep(0.55, 1.00, intensity);
  vec3 phosphor = mix(phosphorBase, phosphorWarm, warmMix);

  // Keep blacks from going “ink black” (TV prop look)
  float blackLift = 0.06;
  vec3 col = phosphor * intensity;
  col = col + phosphor * halo;                 // glass haze
  col = mix(vec3(0.0), col, 1.0 - blackLift) + phosphor * blackLift * intensity;

  gl_FragColor = vec4(col, 1.0);
}
`;


      function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(s) || "shader compile failed");
        }
        return s;
      }

      const prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog) || "program link failed");
      }
      gl.useProgram(prog);

      // Fullscreen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 1, -1, -1, 1,
        -1, 1, 1, -1, 1, 1
      ]), gl.STATIC_DRAW);

      const a_pos = gl.getAttribLocation(prog, "a_pos");
      gl.enableVertexAttribArray(a_pos);
      gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

      const u_tex = gl.getUniformLocation(prog, "u_tex");
      const u_res = gl.getUniformLocation(prog, "u_res");
      const u_time = gl.getUniformLocation(prog, "u_time");
      const u_flip = gl.getUniformLocation(prog, "u_flip");

      // Always flip 180° (works for both mobile and desktop orientations)
      const shouldFlip = true;

      // Hide hint when camera is active
      document.getElementById('hint').style.display = 'none';

      // Video texture
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.uniform1i(u_tex, 0);

      const t0 = performance.now();
      function frame() {
        resize();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex);

        // Upload current video frame
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);

        gl.uniform2f(u_res, canvas.width, canvas.height);
        gl.uniform1f(u_time, (performance.now() - t0) / 1000.0);
        gl.uniform1f(u_flip, shouldFlip ? 1.0 : 0.0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(frame);
      }
      frame();
    })();
  </script>
</body>

</html>